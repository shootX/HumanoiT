# Settings განყოფილება – ცვლილებების არ შენახვის ანალიზი

## მიზეზი (ძირითადი)

**ფორმის state არ სინქრონიზდება ახალ props-თან შენახვის შემდეგ.**

როგორ მუშაობს ნაკადი:
1. მომხმარებელი იხსნის Settings გვერდს → `SettingsController::index()` აბრუნებს `systemSettings`, `currencies` და სხვ. (Inertia props).
2. ქვე-კომპონენტები (SystemSettings, CurrencySettings, EmailSettings და ა.შ.) იღებენ ამ მონაცემებს **პროპებად** და **ერთხელ** ინიციალიზაციისას იყენებენ `useState(initialValue)`.
3. მომხმარებელი ცვლის ველებს → იცვლება მხოლოდ **ლოკალური state**.
4. დააჭერს Save → `router.post(...)` → ბექენდი ინახავს და აბრუნებს `redirect()->back()->with('success', ...)`.
5. Inertia აკეთებს ახალ GET იმავე გვერდზე → `SettingsController::index()` კვლავ იძახება და **ახალი** `systemSettings` (და სხვ.) ბრუნდება.
6. **პრობლემა:** იგივე კომპონენტი რჩება mounted; `useState`-ის საწყისი მნიშვნელობა **მხოლოდ პირველ მონტაჟზე** ირჩევა. ახალი props (`settings`, `systemSettings`) მოდის, მაგრამ **ლოკალური state აღარ იხსნება** ამ ახალი props-იდან. ამიტომ ფორმაში ისევ ჩანს **ძველი** მნიშვნელობები და ჩანს, თითქოს „არ იმახსოვრებს“.

**რომელ კომპონენტებს აქვთ ეს პრობლემა (state მხოლოდ ინიციალიზაციაზე, sync-ის useEffect არა):**
- `system-settings.tsx` – არა
- `currency-settings.tsx` – არა (state from `usePage().props`, sync არა)
- `email-settings.tsx` – არა
- `recaptcha-settings.tsx` – არა
- `storage-settings.tsx` – არა
- `seo-settings.tsx` – უნდა შემოწმდეს
- `invoice-settings.tsx` – უნდა შემოწმდეს
- `brand-settings.tsx` – იყენებს context/cookies, ლოგიკა განსხვავებულია

**რომელ კომპონენტებს აქვთ `useEffect` და props → state sync (შეიძლება სწორად იმუშაონ):**
- `chatgpt-settings.tsx` – აქვს `useEffect` settingsData-ზე
- `cookie-settings.tsx` – აქვს `useEffect` settingsData-ზე

ანუ უმეტესობა **არ** სინქრონიზებს state ახალ props-თან redirect-ის შემდეგ.

---

## დამატებითი შესაძლო მიზეზი (ვალიდაცია)

**System Settings:** ბექენდზე `termsConditionsUrl` არის `'nullable|url'`. თუ მომხმარებელი ველს ცარიელს ტოვებს, ფრონტი ხშირად აგზავნის **ცარიელ სტრიქონს** `''`. Laravel-ში `url` წესი ცარიელ სტრიქონზე ვერ გაივლის, ამიტომ ვალიდაცია უკან დააბრუნებს შეცდომას და შენახვა არ მოხდება. ამისთვის ბექენდზე უნდა იყოს ან `nullable` + ცარიელი სტრიქონის გადაკონვერტება `null`-ზე, ან წესი რომ დაშვებული იყოს ცარიელი.

ფაილი: `app/Http/Controllers/Settings/SystemSettingsController.php` → `update()` → validation.

---

## რა უნდა გაკეთდეს (რეკომენდაცია)

1. **ყველა იმ settings ქვე-კომპონენტში**, სადაც ფორმის state მოდის props-იდან (`settings` / `systemSettings` / `usePage().props`):
   - **დაამატოთ `useEffect`**, რომელიც props-ის (ან page props-ის) შესაბამისი ნაწილის ცვლილებაზე **განაახლებს ლოკალურ state-ს** (იმავე სტრუქტურით, როგორაც ინიციალიზაციაში იყენებთ).
   - ან გამოიყენოთ **key** მშობელზე, მაგ. `key={JSON.stringify(systemSettings)}`, რომ props-ის შეცვლისას კომპონენტი გადამონტაჟდეს და state თავიდან ინიციალიზდეს (უფრო მარტივი, მაგრამ ყოველ ცვლილებაზე რე-მონტაჟი).

2. **System Settings ვალიდაცია:** `termsConditionsUrl`-ისთვის დარწმუნდით, რომ ცარიელი სტრიქონი არ იგზავნება ან ბექენდზე ცარიელი მიიღება როგორც `null` (მაგ. `nullable|url` + request-ში `''` → `null`).

3. **Demo / Plan:** Settings როუტები არის `plan.access` middleware-ში. თუ SaaS რეჟიმშია და კომპანიას არ აქვს აქტიური პლანი, POST შეიძლება გადამისამართდეს plans გვერდზე და შენახვა არასდროს არ მოხდეს. ეს უკვე ცალკე ქცევაა, მაგრამ თუ „არ იმახსოვრებს“ მხოლოდ ზოგიერთ როლზე/კომპანიაზე ხდება, ღირს შემოწმება.

---

## შეჯამება

| პრობლემა | აღწერა |
|----------|--------|
| **State არ სინქრონიზდება** | ფორმის state ივსება მხოლოდ პირველი მონტაჟისას. redirect-ის შემდეგ მოდის ახალი props, მაგრამ state ძველი რჩება → იკითხება როგორც „ცვლილება არ იმახსოვრებს“. |
| **ვალიდაცია (termsConditionsUrl)** | ცარიელი ველი `''` ვერ გაივლის `url` წესს, შენახვა ვერ მოხდება. |
| **შესაძლო plan.access** | SaaS-ში პლანის გარეშე POST შეიძლება redirect-ით „გაუქმდეს“. |

სანამ რამეს შეცვლით, დაეთანხმეთ ზემოთ მოცემულ მიდგომას (useEffect ან key + ვალიდაციის გასწორება) და მაშინ განახორციელოთ ცვლილებები.
